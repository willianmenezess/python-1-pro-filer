# Project ProFiler - Eletiva Back-end com Python

Reposit√≥rio do projeto ProFiler.
  
<details>
<summary><strong>üßë‚Äçüíª O que dever√° ser desenvolvido</strong></summary>

Voc√™ ir√° trabalhar com uma aplica√ß√£o com uma interface de linha de comando (CLI) que recebe como entrada um caminho (diret√≥rio ou arquivo) e gera um relat√≥rio com informa√ß√µes sobre o caminho informado.

Para executar a aplica√ß√£o:

1. Siga os passos do t√≥pico [**üèïÔ∏è Ambiente Virtual**]
2. Configure o auto-complete da aplica√ß√£o com o comando `pro-filer --install-completion` e reinicie o terminal;
3. Execute o comando `pro-filer` seguido de um caminho (diret√≥rio ou arquivo) e uma a√ß√£o. Por exemplo:

```bash
pro-filer . preview
```

![pro-filer preview](./images/pro-filer-preview.gif)

A aplica√ß√£o j√° est√° funcional, mas possui dois problemas:

1. alguns bugs precisam ser corrigidos;
2. mais testes precisam ser implementados.

Voc√™ dever√° corrigir os bugs e implementar os testes para garantir que a aplica√ß√£o funcione corretamente. Ser√° o momento de aplicar tudo o que voc√™ aprendeu sobre debugging e testes automatizados em Python!

</details>
  
<details>
  <summary><strong>:memo: Habilidades a serem trabalhadas </strong></summary>

Neste projeto, verificamos se voc√™ √© capaz de:

- Encontrar bugs no c√≥digo de uma aplica√ß√£o escrita em Python;
- Corrigir bugs no c√≥digo de uma aplica√ß√£o escrita em Python;
- Criar testes para uma aplica√ß√£o escrita em Python;
- Utilizar o `pytest` para criar testes automatizados em uma aplica√ß√£o escrita em Python.

<!-- ü§î [HS] Escrevam as habilidade utilizando a Taxonomia de Bloom. -->

</details>

<details>
<summary><strong>‚Äº Antes de come√ßar a desenvolver</strong></summary>

<!-- ü§î [HS] Aqui, deve-se adicionar os comandos mais utilizados e orienta√ß√µes de como preparar o reposit√≥rio. Atualize o nome do reposit√≥rio do projeto nas instru√ß√µes a seguir -->

1. Clone o reposit√≥rio

- Use o comando: `git clone git@github.com:tryber/python-029-python-projeto-pro-filer.git`
- Entre na pasta do reposit√≥rio que voc√™ acabou de clonar:
  - `cd python-029-python-projeto-pro-filer`

2. Instale as depend√™ncias

    - Siga os passos do t√≥pico [**üèïÔ∏è Ambiente Virtual**]

3. Crie uma branch a partir da branch `main`

- Verifique que voc√™ est√° na branch `main`
  - Exemplo: `git branch`
- Se voc√™ n√£o estiver, mude para a branch `main`
  - Exemplo: `git checkout main`
- Agora, crie uma branch √† qual voc√™ vai submeter os `commits` do seu projeto:
  - Voc√™ deve criar uma branch no seguinte formato: `nome-sobrenome-nome-do-projeto`;
  - Exemplo: `git checkout -b maria-soares-pro-filer`

4. Crie na raiz do projeto os arquivos que voc√™ precisar√° desenvolver:

- Verifique que voc√™ est√° na raiz do projeto:
  - Exemplo: `pwd` -> o retorno vai ser algo tipo _/Users/maria/code/**python-029-python-projeto-pro-filer**_
- Crie ou edite algum arquivo necess√°rio ao projeto

5. Adicione as mudan√ßas ao _stage_ do Git e fa√ßa um `commit`

- Verifique que as mudan√ßas ainda n√£o est√£o no _stage_:
  - Exemplo: `git status` (devem aparecer listados os novos arquivos em vermelho)
- Adicione o novo arquivo ao _stage_ do Git:
  - Exemplo:
    - `git add .` (adicionando todas as mudan√ßas - _que estavam em vermelho_ - ao stage do Git)
    - `git status` (devem aparecer listados os arquivos em verde)
- Fa√ßa o `commit` inicial:
  - Exemplo:
    - `git commit -m 'iniciando o projeto. VAMOS COM TUDO :rocket:'` (fazendo o primeiro commit)
    - `git status` (deve aparecer uma mensagem tipo _nothing to commit_ )

6. Adicione a sua branch com o novo `commit` ao reposit√≥rio remoto

- Usando o exemplo anterior: `git push -u origin maria-soares-pro-filer`

7. Crie um novo `Pull Request` _(PR)_

- V√° at√© a p√°gina de _Pull Requests_ do reposit√≥rio no GitHub em `<url_do_reposit√≥rio>/pulls`:
  - Clique no bot√£o verde _"New pull request"_
  - Clique na caixa de sele√ß√£o _"Compare"_ e escolha a sua branch **com aten√ß√£o**
- Coloque um t√≠tulo para o seu _Pull Request_
  - Exemplo: _"Cria tela de busca"_
- Clique no bot√£o verde _"Create pull request"_

- Adicione uma descri√ß√£o para o _Pull Request_, um t√≠tulo n√≠tido que o identifique, e clique no bot√£o verde _"Create pull request"_

 <img width="1335" alt="Exemplo de pull request" src="https://user-images.githubusercontent.com/42356399/166255109-b95e6eb4-2503-45e5-8fb3-cf7caa0436e5.png">

- Volte at√© a p√°gina de _Pull Requests_ do reposit√≥rio no GitHub em `<url_do_reposit√≥rio>/pulls` e confira que o seu _Pull Request_ est√° criado

</details>

<details>
  <summary><strong>üèïÔ∏è Ambiente Virtual</strong></summary>
  O Python oferece um recurso chamado de ambiente virtual, onde permite sua m√°quina rodar sem conflitos, diferentes tipos de projetos com diferentes vers√µes de bibliotecas.

  1. **criar o ambiente virtual**

  ```bash
  python3 -m venv .venv
  ```

  2. **ativar o ambiente virtual**

  ```bash
  source .venv/bin/activate
  ```

  3. **instalar as depend√™ncias no ambiente virtual**

  ```bash
  python3 -m pip install -r dev-requirements.txt
  ```

  Com o seu ambiente virtual ativo, as depend√™ncias ser√£o instaladas neste ambiente.
  Quando precisar desativar o ambiente virtual, execute o comando `deactivate`. Lembre-se de ativar novamente quando voltar a trabalhar no projeto.

  O arquivo `dev-requirements.txt` instalar√° todas as depend√™ncias que ser√£o utilizadas no projeto, ele est√° agindo como se fosse um `package.json` de um projeto `Node.js`. Se voc√™ desejar instalar uma nova depend√™ncia, basta adicion√°-la no arquivo `dev-requirements.txt` e executar o comando `python3 -m pip install -r dev-requirements.txt` novamente.

  Se o VS Code n√£o reconhecer as depend√™ncias instaladas no ambiente virtual criado, ser√° necess√°rio informar o caminho do interpretador Python. Para isso, abra o VS Code e pressione `Ctrl + Shift + P` (no Mac, `Cmd + Shift + P`) e digite `Python: Select Interpreter`. Selecione o interpretador que possui o caminho `./.venv/bin/python` no nome.
</details>

<details>
<summary><strong>üéõ Linter</strong></summary>

Para garantir a qualidade do c√≥digo, vamos utilizar nesse projeto o linter `Flake8`. Assim o c√≥digo estar√° alinhado com as boas pr√°ticas de desenvolvimento, sendo mais leg√≠vel e de f√°cil manuten√ß√£o! Para poder executar o `Flake8`, certifique-se de ter seguido os passos do t√≥pico [**üèïÔ∏è Ambiente Virtual**] dentro do reposit√≥rio.

Para rod√°-lo localmente no reposit√≥rio, execute o comando a seguir:

```bash
python3 -m flake8
```

Se a an√°lise do `Flake8` encontrar problemas no seu c√≥digo, tais problemas ser√£o mostrados no seu terminal. Se n√£o houver problema no seu c√≥digo, nada ser√° impresso no seu terminal.

</details>

<details>
  <summary><strong>üõ† Testes</strong></summary>

  Para executar os testes certifique-se de que voc√™ est√° com o ambiente virtual ativado.

  <strong>Executar os testes</strong>

  ```bash
  python3 -m pytest
  ```

  O arquivo `pyproject.toml` j√° configura corretamente o `pytest`. Entretanto, caso voc√™ tenha problemas com isso e queira explicitamente uma sa√≠da completa, o comando √©:

  ```bash
  python3 -m pytest -s -vv --continue-on-collection-errors
  ```

  O `pytest` possui diversos par√¢metros que podem ser utilizados para executar os testes de diferentes formas. Alguns exemplos s√£o:

  ```bash
  python3 -m pytest tests/test_nome_do_arquivo.py  # Executa todos os testes do arquivo de testes especificado
  python3 -m pytest tests/test_nome_do_arquivo.py::test_nome_do_teste  # Executa apenas o teste especificado
  python3 -m pytest -k expressao  # Executa apenas os testes que cont√©m a express√£o informada como substring
  python3 -m pytest -x  # Executa os testes at√© encontrar o primeiro erro
  ```

  Voc√™ pode combinar os par√¢metros para executar os testes da forma que desejar! Para mais informa√ß√µes, consulte a [documenta√ß√£o do pytest](https://docs.pytest.org/en/7.3.x/contents.html).
</details>

## Requisitos do projeto

### 1. Elimine o(s) bug(s) da fun√ß√£o `show_deepest_file`

> Arquivo a ser alterado: `pro_filer/actions/beta_actions.py`

Voc√™ est√° colaborando com a comunidade open-source e recebeu uma tarefa de corrigir bugs em algumas fun√ß√µes!

Encontre e corrija o(s) bug(s) da fun√ß√£o `show_deepest_file` para que ela informe corretamente o caminho arquivo mais profundo dentro do diret√≥rio informado.

Execute os testes do arquivo `tests/actions/test_deepest_file.py` para te ajudar a encontrar o(s) bug(s): **voc√™ saber√° que o(s) bug(s) foi(ram) corrigido(s) quando todos os testes desse arquivo passarem.**

<details>

<summary> ü§ñ Comportamento esperado da fun√ß√£o <code>show_deepest_file</code> </summary>

A fun√ß√£o `show_deepest_file` deve receber um dicion√°rio `context` com a chave `all_files` e imprime na sa√≠da padr√£o (`stdout`) o caminho do arquivo mais profundo dentro do diret√≥rio informado. A chave `all_files` armazena uma lista de strings, que representam os caminhos de todos os arquivos dentro de um diret√≥rio.

**O caminho mais profundo** ser√° o caminho que possui a maior quantidade de diret√≥rios aninhados. Considere esse exemplo:

```python
context = {
    "all_files": [
        "/home/trybe/Downloads/trybe_logo.png",
        "/home/trybe/Documents/aula/python/tests.txt",
    ]
}

show_deepest_file(context)
# Sa√≠da:
# Deepest file: /home/trybe/Documents/aula/python/tests.txt

context = {
    "all_files": []
}

show_deepest_file(context)
# Sa√≠da:
# No files found
```

Na primeira chamada, o arquivo com caminho mais profundo √© `/home/trybe/Documents/aula/python/tests.txt`, pois ele possui 5 diret√≥rios aninhados: `home`, `trybe` e `Documents`, `aula` e `python`.

Na segunda chamada, n√£o h√° arquivos dentro do diret√≥rio informado, ent√£o a fun√ß√£o imprime `No files found`.

> **De olho na dica üëÄ:** Essa fun√ß√£o pode ser acionada pelo comando `pro-filer <caminho> deepest-file`!

</details>

<details>

<summary> üìå O que ser√° testado </summary>

- A fun√ß√£o `show_deepest_file` deve imprimir, na sa√≠da padr√£o (`stdout`), o caminho do arquivo mais profundo dentro do diret√≥rio informado;
- A fun√ß√£o `show_deepest_file` deve imprimir, na sa√≠da padr√£o (`stdout`), `No files found` caso n√£o haja arquivos listados no dicion√°rio `context`;
- Todos os testes do arquivo `tests/actions/test_deepest_file.py` devem passar.

</details>

### 2. Elimine o(s) bug(s) da fun√ß√£o `find_file_by_name`

> Arquivo a ser alterado: `pro_filer/actions/beta_actions.py`

Com a resolu√ß√£o do √∫ltimo bug, as pessoas respons√°veis pela manuten√ß√£o do projeto ficaram extremamente satisfeitas e agora est√£o solicitando uma nova tarefa para voc√™!

Encontre e corrija o(s) bug(s) da fun√ß√£o `find_file_by_name` para que ela fa√ßa corretamente a busca de arquivos baseada em um termo de busca.

Execute os testes do arquivo `tests/actions/test_find_file_by_name.py` para te ajudar a encontrar o(s) bug(s): **voc√™ saber√° que o(s) bug(s) foi(ram) corrigido(s) quando todos os testes desse arquivo passarem.**
<details>

<summary> ü§ñ Comportamento esperado da fun√ß√£o <code>find_file_by_name</code> </summary>

A fun√ß√£o `find_file_by_name` deve receber como par√¢metro:

- um dicion√°rio `context` com a chave `all_files`, que armazena uma lista de strings, representando os caminhos de todos os arquivos dentro de um diret√≥rio
- uma _string_ `search_term` com a string a ser buscada
- (opcional) um _booleano_ `case_sensitive` que indica se a busca deve ser sens√≠vel a mai√∫sculas e min√∫sculas ou n√£o. O valor padr√£o √© `True`.

O retorno ser√° uma lista de strings com os caminhos dos arquivos que possuem o termo buscado em seu nome.

**A busca √© realizada** considerando apenas o nome do arquivo (com sua extens√£o), ignorando o nome das pastas. Considere esse exemplo:

```python
context = {
    "all_files": [
        "/home/trybe/Downloads/Trybe_logo.png",
        "/home/trybe/Documents/aula/python/tests.py",
    ]
}


find_file_by_name(context, '.py')
# Retorno: ["/home/trybe/Documents/aula/python/tests.py"]

find_file_by_name(context, 'trybe', case_sensitive=False)
# Retorno: ["/home/trybe/Downloads/Trybe_logo.png"]

context = {
    "all_files": []
}

find_file_by_name(context, "trybe")
# Retorno: []
```

Na 1¬™ chamada, apenas o segundo arquivo √© encontrado pois apenas ele possui o termo `.py` em seu nome.

J√° na 2¬™ chamada, apenas o primeiro arquivo √© encontrado, pois apenas ele possui o termo `Trybe` em seu nome. Como `case_sensitive` foi passado como `False`, a busca n√£o diferencia mai√∫sculas de min√∫sculas.

E na 3¬™ chamada, n√£o h√° arquivos dentro do dicion√°rio `context`, ent√£o a fun√ß√£o retorna uma lista vazia.

> **De olho na dica üëÄ:** Essa fun√ß√£o pode ser acionada pelo comando `pro-filer <caminho> search-file <termo_de_busca>`!

</details>

<details>

<summary> üìå O que ser√° testado </summary>

- A fun√ß√£o `find_file_by_name` deve retornar uma lista com todos os caminhos de arquivos que possuem o a string `search_term` em seu nome, ignorando o nome das pastas;
- A fun√ß√£o `find_file_by_name` deve realizar a busca por arquivos considerando corretamente o par√¢metro `case_sensitive`;
- A fun√ß√£o `find_file_by_name` deve retornar uma lista vazia caso n√£o haja arquivos listados no dicion√°rio `context`;
- Todos os testes do arquivo `tests/actions/test_find_file_by_name.py` devem passar.

</details>

### 3. Crie testes para a fun√ß√£o `show_preview`

> Arquivo a ser alterado: `tests/actions/test_show_preview.py`

Agora que voc√™ j√° corrigiu bugs do projeto e mostrou que consegue trabalhar com o `Pytest`, as pessoas encarregadas do projeto solicitaram que voc√™ desenvolva testes para as fun√ß√µes que ainda n√£o foram testadas!

Implemente testes para a fun√ß√£o `show_preview` do arquivo `pro_filer/actions/main_actions.py` para garantir que ela est√° funcionando corretamente. **Os testes devem ser implementados no arquivo `tests/actions/test_show_preview.py`. Voc√™ pode criar quantas fun√ß√µes de teste desejar, desde que respeite o padr√£o do `Pytest`.**

<details>

<summary> ü§ñ Comportamento esperado da fun√ß√£o <code>show_preview</code> </summary>

A fun√ß√£o `show_preview` deve receber como par√¢metro um dicion√°rio `context` com as chaves `all_files` e `all_dirs`:

- `all_files` armazena uma lista de strings, representando os caminhos de todos os arquivos dentro de um diret√≥rio;
- `all_dirs` armazena uma lista de strings, representando os caminhos de todos os diret√≥rios dentro de um diret√≥rio.

A fun√ß√£o imprime na sa√≠da padr√£o (`stdout`):

- A quantidade de arquivos e diret√≥rios listados;
- Se houver algum dado nas chaves do dicion√°rio `context`, os 5 primeiros arquivos listados;
- Se houver algum dado nas chaves do dicion√°rio `context`, os 5 primeiros diret√≥rios listados.

Considere esse exemplo:

```python
context = {
    "all_files": ["src/__init__.py", "src/app.py", "src/utils/__init__.py"],
    "all_dirs": ["src", "src/utils"]
}


show_preview(context)
# Sa√≠da:
# Found 3 files and 2 directories
# First 5 files: ['src/__init__.py', 'src/app.py', 'src/utils/__init__.py']
# First 5 directories: ['src', 'src/utils']


context = {
    "all_files": [],
    "all_dirs": []
}


show_preview(context)
# Sa√≠da:
# Found 0 files and 0 directories
```

Na 1 primeira chamada, a fun√ß√£o imprime as informa√ß√µes como.

Na 2¬™ chamada, n√£o h√° arquivos listados em `all_files`, ent√£o a fun√ß√£o imprime apenas o espa√ßo total ocupado: `0`.

> **De olho na dica üëÄ:** Essa fun√ß√£o pode ser acionada pelo comando `pro-filer <caminho> preview`!

> **De olho na dica üëÄ:** Execute o teste da Trybe `tests/trybe/show_preview_test.py` para verificar se seus testes cobrem todos os casos de uso previstos!

</details>

<details>

<summary> üìå O que ser√° testado </summary>

- Os seus testes rejeitam implementa√ß√µes de `show_preview` que consideram apenas `all_files` e `all_dirs` vazios;
- Os seus testes rejeitam implementa√ß√µes de `show_preview` que exibem mais do que 5 arquivos e/ou diret√≥rios;
- Os seus testes aprovam a implementa√ß√£o de `show_preview` presente em `pro_filer/actions/main_actions.py`.

</details>

<details>
  <summary> üìå Como seu teste √© avaliado </summary>

O **teste da Trybe** ir√° avaliar se os **seus testes** est√£o passando conforme seu objetivo, e se est√£o falhando em alguns casos que deveria falhar.

Executaremos as fun√ß√µes de teste que voc√™ escrever no arquivo indicado (`tests/actions/test_show_preview.py`) substituindo a fun√ß√£o sendo testada (`show_preview`) por outras implementa√ß√µes "quebradas".

‚ùå Se seu teste **aprovar** alguma das implementa√ß√µes "quebradas", **o teste da Trybe FALHAR√Å**, indicando que o requisito **n√£o est√°** aprovado.

‚úÖ Se seu teste **rejeitar** todas as implementa√ß√µes "quebradas", **o teste da Trybe PASSAR√Å**, indicando que o requisito **est√°** aprovado.

</details>

### 4. Crie testes para a fun√ß√£o `show_details`

> Arquivo a ser alterado: `tests/actions/test_show_details.py`

Parab√©ns por todas as contribui√ß√µes feitas at√© aqui! O time respons√°vel pelo projeto est√° gostando do seu trabalho e tem uma nova tarefa para voc√™: criar testes para outra funcionalidade!

Implemente testes para a fun√ß√£o `show_details` do arquivo `pro_filer/actions/main_actions.py` para garantir que ela est√° funcionando corretamente. **Os testes devem ser implementados no arquivo `tests/actions/test_show_details.py`. Voc√™ pode criar quantas fun√ß√µes de teste desejar, desde que respeite o padr√£o do `Pytest`.**

<details>

<summary> ü§ñ Comportamento esperado da fun√ß√£o <code>show_details</code> </summary>

A fun√ß√£o `show_details` deve receber como par√¢metro um dicion√°rio `context` com as chave `base_path`, que armazena uma string representando o caminho do arquivo (ou diret√≥rio) que deve ser analisado. A fun√ß√£o ent√£o imprime na sa√≠da padr√£o (`stdout`) as seguintes informa√ß√µes:

- O nome do arquivo informado;
- O tamanho ocupado pelo arquivo informado;
- O tipo do arquivo informado (`file` ou `directory`);
- A extens√£o do arquivo informado (ou `[no extension]` caso n√£o possua extens√£o);
- A data da √∫ltima modifica√ß√£o do arquivo informado, no formato `yyyy-mm-dd`.

```python
context = {
    "base_path": "/home/trybe/Downloads/Trybe_logo.png"
}


show_details(context)
# Sa√≠da:
# File name: Trybe_logo.png
# File size in bytes: 22438
# File type: file
# File extension: .png
# Last modified date: 2023-06-13


context = {
    "base_path": "/home/trybe/????"
}


show_details(context)
# Sa√≠da:
# File '????' does not exist
```

Na 1¬™ chamada, o arquivo √© um arquivo comum, ent√£o a fun√ß√£o imprime `file` como tipo do arquivo e `.png` como extens√£o.

Na 2¬™ chamada, o arquivo informado n√£o existe, ent√£o a fun√ß√£o imprime `File '????' does not exist`.

> **De olho na dica üëÄ:** Essa fun√ß√£o pode ser acionada pelo comando `pro-filer <caminho> file-details`!

> **De olho na dica üëÄ:** Execute o teste da Trybe `tests/trybe/show_details_test.py` para verificar se seus testes cobrem todos os casos de uso previstos!

</details>

<details>

<summary> üìå O que ser√° testado </summary>

- Os seus testes rejeitam implementa√ß√µes de `show_details` que n√£o utilizam as mensagens corretas para exibir cada informa√ß√£o;
- Os seus testes rejeitam implementa√ß√µes de `show_details` que utilizam o formato de data incorreto;
- Os seus testes rejeitam implementa√ß√µes de `show_details` que n√£o tratam corretamente o caso de o arquivo informado n√£o existir;
- Os seus testes rejeitam implementa√ß√µes de `show_details` que n√£o tratam corretamente o caso de o arquivo n√£o possuir extens√£o;
- Os seus testes aprovam a implementa√ß√£o de `show_details` presente em `pro_filer/actions/main_actions.py`.

</details>

<details>
  <summary> üìå Como seu teste √© avaliado </summary>

O **teste da Trybe** ir√° avaliar se os **seus testes** est√£o passando conforme seu objetivo, e se est√£o falhando em alguns casos que deveria falhar.

Executaremos as fun√ß√µes de teste que voc√™ escrever no arquivo indicado (`tests/actions/test_show_details.py`) substituindo a fun√ß√£o sendo testada (`show_details`) por outras implementa√ß√µes "quebradas".

‚ùå Se seu teste **aprovar** alguma das implementa√ß√µes "quebradas", **o teste da Trybe FALHAR√Å**, indicando que o requisito **n√£o est√°** aprovado.

‚úÖ Se seu teste **rejeitar** todas as implementa√ß√µes "quebradas", **o teste da Trybe PASSAR√Å**, indicando que o requisito **est√°** aprovado.

</details>

### 5. Crie testes para a fun√ß√£o `show_disk_usage`

> Arquivo a ser alterado: `tests/actions/test_show_disk_usage.py`

Continuando suas contribui√ß√µes no projeto, precisamos que voc√™ crie testes para mais uma funcionalidade importante do projeto!

Implemente testes para a fun√ß√£o `show_disk_usage` do arquivo `pro_filer/actions/main_actions.py` para garantir que ela est√° funcionando corretamente. **Os testes devem ser implementados no arquivo `tests/actions/test_show_disk_usage.py`. Voc√™ pode criar quantas fun√ß√µes de teste desejar, desde que respeite o padr√£o do `Pytest`.**

<details>

<summary> ü§ñ Comportamento esperado da fun√ß√£o <code>show_disk_usage</code> </summary>

A fun√ß√£o `show_disk_usage` deve receber como par√¢metro um dicion√°rio `context` com a chave `all_files`, que armazena uma lista de strings representando os caminhos de todos os arquivos dentro de um diret√≥rio. A fun√ß√£o ent√£o imprime na sa√≠da padr√£o (`stdout`) o espa√ßo total ocupado por todos os arquivos dentro do diret√≥rio informado.

A fun√ß√£o ent√£o imprime na sa√≠da padr√£o (`stdout`) as seguintes informa√ß√µes:

- Para cada arquivo listado em `all_files`:
  - O caminho do arquivo;
  - O espa√ßo ocupado pelo arquivo, em bytes;
  - A porcentagem do tamanho ocupado pelo arquivo em rela√ß√£o ao espa√ßo total ocupado (por todos os arquivos listados em `all_files`);
- O espa√ßo total ocupado por todos os arquivos listados em `all_files`, em bytes.

**A listagem de arquivos** √© realizada em ordem decrescente de espa√ßo ocupado. Considere esse exemplo:

```python
context = {
    "all_files": [
        "src/app.py",
        "src/__init__.py",
    ]
}


show_disk_usage(context)
# Sa√≠da:
# 'src/app.py':                                                          2849 (100%)
# 'src/__init__.py':                                                     0 (0%)
# Total size: 2849

context = {
    "all_files": []
}


show_disk_usage(context)
# Sa√≠da:
# Total size: 0
```

Na 1 primeira chamada, a fun√ß√£o imprime a listagem de arquivos e seu tamanho em _bytes_ com a porcentagem do total e, ao final, o espa√ßo total ocupado pelos arquivos listados.

Na 2¬™ chamada, n√£o h√° arquivos listados em `all_files`, ent√£o a fun√ß√£o imprime apenas o espa√ßo total ocupado: `0`.

**Aten√ß√£o ‚ö†Ô∏è:** Como pode ser observado na implementa√ß√£o de `show_disk_usage`, a formata√ß√£o de cada linha da listagem de arquivos √© feita com aux√≠lio da fun√ß√£o `_get_printable_file_path`. N√£o se preocupe em validar o comportamento dessa fun√ß√£o, voc√™ pode criar um dubl√™ de teste para ela.

> **De olho na dica üëÄ:** Essa fun√ß√£o pode ser acionada pelo comando `pro-filer <caminho> disk-usage`!

> **De olho na dica üëÄ:** Execute o teste da Trybe `tests/trybe/show_disk_usage_test.py` para verificar se seus testes cobrem todos os casos de uso previstos!

</details>

<details>

<summary> üìå O que ser√° testado </summary>

- Os seus testes rejeitam implementa√ß√µes de `show_disk_usage` que n√£o calculam corretamente o espa√ßo total ocupado pelos arquivos listados em `all_files`;
- Os seus testes rejeitam implementa√ß√µes de `show_disk_usage` que consideram todos os arquivos como vazios;
- Os seus testes rejeitam implementa√ß√µes de `show_disk_usage` que n√£o ordenam corretamente a listagem de arquivos;
- Os seus testes aprovam a implementa√ß√£o de `show_disk_usage` presente em `pro_filer/actions/main_actions.py`;
- Os seus testes utilizam a fixture `tmp_path` para criar arquivos tempor√°rios.

</details>

<details>
  <summary> üìå Como seu teste √© avaliado </summary>

O **teste da Trybe** ir√° avaliar se os **seus testes** est√£o passando conforme seu objetivo, e se est√£o falhando em alguns casos que deveria falhar.

Executaremos as fun√ß√µes de teste que voc√™ escrever no arquivo indicado (`tests/actions/test_show_disk_usage.py`) substituindo a fun√ß√£o sendo testada (`show_disk_usage`) por outras implementa√ß√µes "quebradas".

‚ùå Se seu teste **aprovar** alguma das implementa√ß√µes "quebradas", **o teste da Trybe FALHAR√Å**, indicando que o requisito **n√£o est√°** aprovado.

‚úÖ Se seu teste **rejeitar** todas as implementa√ß√µes "quebradas", **o teste da Trybe PASSAR√Å**, indicando que o requisito **est√°** aprovado.

</details>

### 6. Crie testes para a fun√ß√£o `find_duplicate_files`

> Arquivo a ser alterado: `tests/actions/test_find_duplicate_files.py`

Para concluir sua participa√ß√£o na temporada de melhorias, as pessoas respons√°veis pelo projeto t√™m uma √∫ltima tarefa para voc√™: criar testes para uma funcionalidade final!

Implemente testes para a fun√ß√£o `find_duplicate_files` do arquivo `pro_filer/actions/main_actions.py` para garantir que ela est√° funcionando corretamente. **Os testes devem ser implementados no arquivo `tests/actions/test_find_duplicate_files.py`. Voc√™ pode criar quantas fun√ß√µes de teste desejar, desde que respeite o padr√£o do `Pytest`.**

<details>

<summary> ü§ñ Comportamento esperado da fun√ß√£o <code>find_duplicate_files</code> </summary>

A fun√ß√£o `find_duplicate_files` deve receber como par√¢metro um dicion√°rio `context` com a chave `all_files`, que armazena uma lista de strings representando os caminhos de todos os arquivos dentro de um diret√≥rio.

A fun√ß√£o ent√£o retorna uma lista de tuplas com os pares de arquivos que possuem o mesmo conte√∫do.

Considere esse exemplo:

```python
context = {
    "all_files": [
        ".gitignore",
        "src/app.py",
        "src/utils/__init__.py",
    ]
}


find_duplicate_files(context)
# Retorno:
# []

context = {
    "all_files": [
        "./tests/__init__.py",
        "./tests/actions/__init__.py",
        "./pro_filer/__init__.py",
    ]
}

find_duplicate_files(context)
# Retorno:
# [
#     ('./tests/__init__.py', './tests/actions/__init__.py'),
#     ('./tests/__init__.py', './pro_filer/__init__.py'),
#     ('./tests/actions/__init__.py', './pro_filer/__init__.py')
# ]
```

Na 1 primeira chamada, o resultado √© uma lista vazia pois n√£o h√° arquivos duplicados: todos os arquivos possuem conte√∫dos diferentes.

Na 2¬™ chamada, o resultado √© uma lista de tuplas com todos os pares de arquivos duplicados. Como todos os arquivos possuem o mesmo conte√∫do, todos os pares s√£o retornados.

> **Aten√ß√£o ‚ö†Ô∏è:** Como pode ser observado na implementa√ß√£o de `find_duplicate_files`, a compara√ß√£o de conte√∫do de arquivos √© feita com aux√≠lio da fun√ß√£o `filecmp.cmp(...)`. Essa fun√ß√£o √© nativa do Python, e compara o conte√∫do dos arquivos (retornando `True` se forem iguais). Caso algum dos arquivos n√£o exista, √© levantada uma exce√ß√£o `FileNotFoundError`.

Caso a exce√ß√£o `FileNotFoundError` seja levantada na chamada de `filecmp.cmp(...)`, a fun√ß√£o `find_duplicate_files` levantar√° uma exce√ß√£o `ValueError`. Voc√™ deve testar se a exce√ß√£o `ValueError` √© levantada caso algum arquivo em `all_files` n√£o exista.

> **De olho na dica üëÄ:** Essa fun√ß√£o pode ser acionada pelo comando `pro-filer <caminho> find-duplicate`!

> **De olho na dica üëÄ:** Execute o teste da Trybe `tests/trybe/find_duplicate_test.py` para verificar se seus testes cobrem todos os casos de uso previstos!

</details>

<details>

<summary> üìå O que ser√° testado </summary>

- Os seus testes rejeitam implementa√ß√µes de `find_duplicate_files` que consideram todos os arquivos em `all_files` como diferentes;
- Os seus testes rejeitam implementa√ß√µes de `find_duplicate_files` que consideram todos os arquivos em `all_files` como iguais;
- Os seus testes rejeitam implementa√ß√µes de `find_duplicate_files` que n√£o levanta `ValueError` caso algum arquivo em `all_files` n√£o exista;
- Os seus testes aprovam a implementa√ß√£o de `find_duplicate_files` presente em `pro_filer/actions/main_actions.py`;
- Os seus testes utilizam a fixture `tmp_path` para criar arquivos tempor√°rios.

</details>

<details>
  <summary> üìå Como seu teste √© avaliado </summary>

O **teste da Trybe** ir√° avaliar se os **seus testes** est√£o passando conforme seu objetivo, e se est√£o falhando em alguns casos que deveria falhar.

Executaremos as fun√ß√µes de teste que voc√™ escrever no arquivo indicado (`tests/actions/test_show_disk_usage.py`) substituindo a fun√ß√£o sendo testada (`show_disk_usage`) por outras implementa√ß√µes "quebradas".

‚ùå Se seu teste **aprovar** alguma das implementa√ß√µes "quebradas", **o teste da Trybe FALHAR√Å**, indicando que o requisito **n√£o est√°** aprovado.

‚úÖ Se seu teste **rejeitar** todas as implementa√ß√µes "quebradas", **o teste da Trybe PASSAR√Å**, indicando que o requisito **est√°** aprovado.

</details>

---

<!-- mdi vers√£o 1.0 projeto python ‚ö†Ô∏è n√£o exclua esse coment√°rio -->
